from rest_framework import viewsets, status
from rest_framework.permissions import IsAuthenticated, AllowAny
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.decorators import action, api_view, permission_classes
from django.http import JsonResponse
from django.db.models import Q
import json
import requests
import time
from .forms import MessageContactForm
from django.contrib import messages
from .serializers import (
    CliniqueSerializer, DentisteSerializer, HopitalSerializer, PharmacieSerializer, 
    RendezVousSerializer, TraitementSerializer, ConsultationSerializer, ConsultationMessageSerializer,
    PatientSerializer, MedecinSerializer, MedicamentSerializer,
    PathologieSerializer, ConstanteSerializer, MesureSerializer, ArticleSerializer, 
    StructureDeSanteSerializer, ServiceSerializer, ContactFooterSerializer, 
    ChatbotConversationSerializer, MedicalDocumentSerializer, ChatbotKnowledgeBaseSerializer, 
    RendezVousCreateSerializer, DisponibiliteMedecinSerializer, IndisponibiliteMedecinSerializer,
    RegisterSerializer
)
from django.contrib.auth.models import User
from django.contrib.auth import authenticate, get_user_model
from rest_framework_simplejwt.tokens import RefreshToken
from django.utils.timezone import now
from django.shortcuts import get_object_or_404
import os
from django.conf import settings
from django.http import HttpResponse
import logging
from .notifications import NotificationService

# Add these imports for admin statistics
from django.db.models import Count
from datetime import date, timedelta, datetime, time as datetime_time
from .models import log_action, Patient, Medecin, RendezVous, Consultation, Medicament, Pathologie, Traitement, Constante, Mesure, Article, StructureDeSante, Service, Hopital, Clinique, Dentiste, Pharmacie, ChatbotConversation, ContactFooter, MedicalDocument, ChatbotKnowledgeBase, ConsultationMessage, Teleconsultation, DisponibiliteMedecin, IndisponibiliteMedecin

logger = logging.getLogger(__name__)

# Utility function for robust conflict detection
def check_appointment_conflict(medecin_user, date_rdv, heure_rdv, duration_minutes, exclude_rdv_id=None):
    """
    Check if there's a conflict with existing appointments
    Returns tuple: (has_conflict, conflicting_appointment)
    """
    # Calculate time range for the new appointment
    new_start = datetime.combine(date_rdv, heure_rdv)
    new_end = new_start + timedelta(minutes=duration_minutes)
    
    # Get existing appointments for this doctor on this date
    existing_appointments = RendezVous.objects.filter(
        medecin=medecin_user,
        date=date_rdv,
        statut__in=['CONFIRMED', 'PENDING']
    )
    
    # Exclude the current appointment if we're updating
    if exclude_rdv_id:
        existing_appointments = existing_appointments.exclude(id=exclude_rdv_id)
    
    # Check each existing appointment for time overlap
    for appointment in existing_appointments:
        # Get the doctor's availability for this appointment's day to get the correct duration
        appt_jour_semaine = appointment.date.strftime('%A').lower()
        jour_mapping = {
            'monday': 'lundi',
            'tuesday': 'mardi',
            'wednesday': 'mercredi',
            'thursday': 'jeudi',
            'friday': 'vendredi',
            'saturday': 'samedi',
            'sunday': 'dimanche'
        }
        appt_jour_fr = jour_mapping.get(appt_jour_semaine, '')
        
        try:
            # Get the doctor's availability for this day to determine appointment duration
            medecin = Medecin.objects.get(user=medecin_user)
            appt_disponibilite = DisponibiliteMedecin.objects.get(
                medecin=medecin, 
                jour=appt_jour_fr, 
                actif=True
            )
            appt_duree = timedelta(minutes=appt_disponibilite.duree_consultation)
        except (Medecin.DoesNotExist, DisponibiliteMedecin.DoesNotExist):
            # Fallback to default 30 minutes if no availability found
            appt_duree = timedelta(minutes=30)
        
        # Calculate appointment time range
        appt_start = datetime.combine(appointment.date, appointment.heure)
        appt_end = appt_start + appt_duree
        
        # Check for time overlap using strict overlap detection
        # Two intervals [a,b) and [c,d) overlap if a < d and c < b
        if new_start < appt_end and appt_start < new_end:
            return True, appointment
    
    return False, None

# --------------------
# Patients
# --------------------
class PatientViewSet(viewsets.ModelViewSet):
    queryset = Patient.objects.all()
    serializer_class = PatientSerializer

    def get_queryset(self):
        return Patient.objects.all()

    def get_permissions(self):
        # rendre accessible en lecture seule publiquement
        if self.action in ['list', 'retrieve']:
            return [AllowAny()]
        return [IsAuthenticated()]

# --------------------
# M√©decins
# --------------------
class MedecinViewSet(viewsets.ModelViewSet):
    queryset = Medecin.objects.all()
    serializer_class = MedecinSerializer

    def get_queryset(self):
        return Medecin.objects.all()

    def get_permissions(self):
        if self.action in ['list', 'retrieve']:
            return [AllowAny()]
        return [IsAuthenticated()]

# --------------------
# Rendez-vous
# --------------------
class RendezVousViewSet(viewsets.ModelViewSet):
    queryset = RendezVous.objects.all()
    serializer_class = RendezVousSerializer

    def get_queryset(self):
        return RendezVous.objects.all()

    def get_permissions(self):
        if self.action in ['list', 'retrieve']:
            return [AllowAny()]
        return [IsAuthenticated()]
    
    def get_serializer_class(self):
        if self.action == 'create':
            return RendezVousCreateSerializer
        return RendezVousSerializer
    
    @action(detail=False, methods=['get'], permission_classes=[IsAuthenticated])
    def creneaux_disponibles(self, request):
        """
        Get available time slots for a doctor on a specific date
        Query parameters: medecin_id, date
        """
        from .models import DisponibiliteMedecin, IndisponibiliteMedecin, RendezVous
        from django.utils import timezone
        import datetime
        
        medecin_id = request.query_params.get('medecin_id')
        date_str = request.query_params.get('date')
        
        if not medecin_id or not date_str:
            return Response({'error': 'medecin_id and date are required'}, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            # Get the doctor
            medecin = Medecin.objects.get(id=medecin_id)
            date_obj = datetime.datetime.strptime(date_str, '%Y-%m-%d').date()
        except Medecin.DoesNotExist:
            return Response({'error': 'M√©decin non trouv√©'}, status=status.HTTP_404_NOT_FOUND)
        except ValueError:
            return Response({'error': 'Format de date invalide'}, status=status.HTTP_400_BAD_REQUEST)
        
        # Check if the date is in the past
        if date_obj < timezone.now().date():
            return Response({'error': 'Impossible de r√©server dans le pass√©'}, status=status.HTTP_400_BAD_REQUEST)
        
        # Check for doctor's unavailability
        indisponible = IndisponibiliteMedecin.objects.filter(
            medecin=medecin,
            date_debut__lte=date_obj,
            date_fin__gte=date_obj
        ).exists()
        
        if indisponible:
            return Response({'creneaux': [], 'message': 'Le m√©decin est indisponible √† cette date'})
        
        # Get doctor's availability for the day
        jour_semaine = date_obj.strftime('%A').lower()
        jour_mapping = {
            'monday': 'lundi',
            'tuesday': 'mardi',
            'wednesday': 'mercredi',
            'thursday': 'jeudi',
            'friday': 'vendredi',
            'saturday': 'samedi',
            'sunday': 'dimanche'
        }
        jour_fr = jour_mapping.get(jour_semaine, '')
        
        try:
            disponibilite = DisponibiliteMedecin.objects.get(medecin=medecin, jour=jour_fr, actif=True)
        except DisponibiliteMedecin.DoesNotExist:
            return Response({'creneaux': [], 'message': f'Le m√©decin n\'est pas disponible le {jour_fr}'})
        
        # Generate available time slots with detailed information
        creneaux_details = []
        heure_courante = disponibilite.heure_debut
        duree_consultation = datetime.timedelta(minutes=disponibilite.duree_consultation)
        
        while heure_courante < disponibilite.heure_fin:
            # Check if this time slot is during lunch break
            if disponibilite.pause_dejeuner_debut and disponibilite.pause_dejeuner_fin:
                if disponibilite.pause_dejeuner_debut <= heure_courante < disponibilite.pause_dejeuner_fin:
                    heure_courante = (datetime.datetime.combine(date_obj, heure_courante) + duree_consultation).time()
                    continue
            
            # Use the robust conflict detection function
            conflit, _ = check_appointment_conflict(
                medecin.user,
                date_obj,
                heure_courante,
                disponibilite.duree_consultation
            )
            
            # Check if the slot is at least 2 hours in the future
            slot_datetime = datetime.datetime.combine(date_obj, heure_courante)
            is_future = slot_datetime >= timezone.now() + datetime.timedelta(hours=2)
            
            # Also check if slot is today but time has passed
            is_today = date_obj == timezone.now().date()
            if is_today and heure_courante <= timezone.now().time():
                is_future = False
            
            if not conflit and is_future:
                creneaux_details.append({
                    "heure": heure_courante.strftime('%H:%M'),
                    "disponible": True,
                    "motif_indisponibilite": None
                })
            elif conflit:
                creneaux_details.append({
                    "heure": heure_courante.strftime('%H:%M'),
                    "disponible": False,
                    "motif_indisponibilite": "D√©j√† r√©serv√©"
                })
            elif not is_future:
                creneaux_details.append({
                    "heure": heure_courante.strftime('%H:%M'),
                    "disponible": False,
                    "motif_indisponibilite": "Dans le pass√©"
                })
            
            heure_courante = (datetime.datetime.combine(date_obj, heure_courante) + duree_consultation).time()
        
        return Response({'creneaux': creneaux_details})
    
    @action(detail=True, methods=['get'], permission_classes=[IsAuthenticated])
    def prochains_creneaux(self, request, pk=None):
        """
        Get next available slots for a doctor
        Query parameters: limit (default 5)
        """
        from .models import DisponibiliteMedecin, IndisponibiliteMedecin, RendezVous
        from django.utils import timezone
        import datetime
        
        limit = int(request.query_params.get('limit', 5))
        
        try:
            # Get the doctor
            medecin = Medecin.objects.get(id=pk)
        except Medecin.DoesNotExist:
            return Response({'error': 'M√©decin non trouv√©'}, status=status.HTTP_404_NOT_FOUND)
        
        # Get all doctor's availabilities
        disponibilites = DisponibiliteMedecin.objects.filter(medecin=medecin, actif=True)
        
        creneaux_trouves = []
        current_date = timezone.now().date()
        
        # Try to find next available slots
        for i in range(30):  # Check next 30 days
            check_date = current_date + datetime.timedelta(days=i)
            jour_semaine = check_date.strftime('%A').lower()
            jour_mapping = {
                'monday': 'lundi',
                'tuesday': 'mardi',
                'wednesday': 'mercredi',
                'thursday': 'jeudi',
                'friday': 'vendredi',
                'saturday': 'samedi',
                'sunday': 'dimanche'
            }
            jour_fr = jour_mapping.get(jour_semaine, '')
            
            # Check if doctor is unavailable this day
            indisponible = IndisponibiliteMedecin.objects.filter(
                medecin=medecin,
                date_debut__lte=check_date,
                date_fin__gte=check_date
            ).exists()
            
            if indisponible:
                continue
            
            # Get doctor's availability for this day
            try:
                disponibilite = disponibilites.get(jour=jour_fr)
            except DisponibiliteMedecin.DoesNotExist:
                continue
            
            # Generate time slots for this day
            heure_courante = disponibilite.heure_debut
            duree_consultation = datetime.timedelta(minutes=disponibilite.duree_consultation)
            
            while heure_courante < disponibilite.heure_fin and len(creneaux_trouves) < limit:
                # Check if this time slot is during lunch break
                if disponibilite.pause_dejeuner_debut and disponibilite.pause_dejeuner_fin:
                    if disponibilite.pause_dejeuner_debut <= heure_courante < disponibilite.pause_dejeuner_fin:
                        heure_courante = (datetime.datetime.combine(check_date, heure_courante) + duree_consultation).time()
                        continue
                
                # Use the robust conflict detection function
                conflit, _ = check_appointment_conflict(
                    medecin.user,
                    check_date,
                    heure_courante,
                    disponibilite.duree_consultation
                )
                
                # Check if the slot is at least 2 hours in the future
                slot_datetime = datetime.datetime.combine(check_date, heure_courante)
                is_future = slot_datetime >= timezone.now() + datetime.timedelta(hours=2)
                
                # Also check if slot is today but time has passed
                is_today = check_date == timezone.now().date()
                if is_today and heure_courante <= timezone.now().time():
                    is_future = False
                
                if not conflit and is_future:
                    creneaux_trouves.append({
                        "date": check_date.strftime('%Y-%m-%d'),
                        "heure": heure_courante.strftime('%H:%M'),
                        "datetime": slot_datetime.isoformat()
                    })
                
                heure_courante = (datetime.datetime.combine(check_date, heure_courante) + duree_consultation).time()
                
                if len(creneaux_trouves) >= limit:
                    break
            
            if len(creneaux_trouves) >= limit:
                break
        
        return Response({'creneaux': creneaux_trouves})

                        "date": check_date.strftime('%Y-%m-%d'),
                        "heure": heure_courante.strftime('%H:%M'),
                        "datetime": slot_start.isoformat()
                    })
                
                heure_courante = (datetime.datetime.combine(check_date, heure_courante) + duree_consultation).time()
                
                if len(creneaux_trouves) >= limit:
                    break
            
            if len(creneaux_trouves) >= limit:
                break
        
        return Response({'creneaux': creneaux_trouves})
    
    def perform_create(self, serializer):
        # Auto-assign patient from authenticated user if not provided
        if not serializer.validated_data.get('patient'):
            serializer.save(patient=self.request.user)
        else:
            serializer.save()
        
        # Send notification to the doctor
        from .notifications import NotificationService
        try:
            # Get the appointment instance after saving
            appointment = serializer.instance
            NotificationService.send_appointment_request_notification(appointment)
        except Exception as e:
            print(f"Error sending appointment notification: {e}")

# --------------------
# Consultations
# --------------------
class ConsultationViewSet(viewsets.ModelViewSet):
    queryset = Consultation.objects.all()
    serializer_class = ConsultationSerializer

    def get_queryset(self):
        user = self.request.user
        if user.is_authenticated:
            if user.role == 'medecin':
                # Doctors can see their consultations
                return Consultation.objects.filter(medecin=user.medecin_profile)
            elif user.role == 'patient':
                # Patients can see their consultations
                return Consultation.objects.filter(patient=user.patient_profile)
        return Consultation.objects.none()

    def get_permissions(self):
        if self.action in ['list', 'retrieve']:
            return [IsAuthenticated()]
        return [IsAuthenticated()]
    
    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def start(self, request, pk=None):
        """Start an online consultation"""
        consultation = self.get_object()
        user = request.user
        
        # Check if user is authorized (patient or doctor of this consultation)
        if not (user == consultation.patient.user or user == consultation.medecin.user):
            return Response(
                {'error': 'Vous n\'√™tes pas autoris√© √† d√©marrer cette consultation'}, 
                status=status.HTTP_403_FORBIDDEN
            )
        
        # Update consultation status
        consultation.statut = 'en_cours'
        consultation.save()
        
        return Response({
            'message': 'Consultation d√©marr√©e avec succ√®s',
            'consultation': ConsultationSerializer(consultation).data
        })
    
    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def end(self, request, pk=None):
        """End an online consultation"""
        consultation = self.get_object()
        user = request.user
        
        # Check if user is authorized (patient or doctor of this consultation)
        if not (user == consultation.patient.user or user == consultation.medecin.user):
            return Response(
                {'error': 'Vous n\'√™tes pas autoris√© √† terminer cette consultation'}, 
                status=status.HTTP_403_FORBIDDEN
            )
        
        # Update consultation status
        consultation.statut = 'terminee'
        consultation.save()
        
        return Response({
            'message': 'Consultation termin√©e avec succ√®s',
            'consultation': ConsultationSerializer(consultation).data
        })


# --------------------
# Consultation Messages
# --------------------
class ConsultationMessageViewSet(viewsets.ModelViewSet):
    queryset = ConsultationMessage.objects.all()
    serializer_class = ConsultationMessageSerializer

# -------------------- Teleconsultation --------------------
from .models import Teleconsultation
from .serializers import TeleconsultationSerializer
import uuid
import os
from django.conf import settings

# Try to import Agora token builder
try:
    from agora_token_builder import RtcTokenBuilder
    AGORA_AVAILABLE = True
except ImportError:
    RtcTokenBuilder = None
    AGORA_AVAILABLE = False

class TeleconsultationViewSet(viewsets.ModelViewSet):
    queryset = Teleconsultation.objects.all()
    serializer_class = TeleconsultationSerializer
    permission_classes = [IsAuthenticated]
    
    def get_queryset(self):
        user = self.request.user
        if user.is_authenticated:
            if user.role == 'medecin':
                # Doctors can see their teleconsultations
                return Teleconsultation.objects.filter(consultation__medecin=user.medecin_profile)
            elif user.role == 'patient':
                # Patients can see their teleconsultations
                return Teleconsultation.objects.filter(consultation__patient=user.patient_profile)
        return Teleconsultation.objects.none()
    
    def create(self, request, *args, **kwargs):
        consultation_id = request.data.get('consultation')
        if not consultation_id:
            return Response({'error': 'Consultation ID is required'}, status=status.HTTP_400_BAD_REQUEST)
        
        # Check if teleconsultation already exists for this consultation
        try:
            teleconsultation = Teleconsultation.objects.get(consultation_id=consultation_id)
            serializer = self.get_serializer(teleconsultation)
            return Response(serializer.data, status=status.HTTP_200_OK)
        except Teleconsultation.DoesNotExist:
            pass
        
        # Create new teleconsultation with unique channel name
        channel_name = f"teleconsultation_{consultation_id}_{uuid.uuid4().hex[:8]}"
        teleconsultation = Teleconsultation.objects.create(
            consultation_id=consultation_id,
            channel_name=channel_name
        )
        
        serializer = self.get_serializer(teleconsultation)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
    
    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def generate_token(self, request, pk=None):
        """Generate Agora token for a teleconsultation"""
        # Check if Agora is available
        if not AGORA_AVAILABLE:
            return Response(
                {'error': 'Agora token builder not available. Teleconsultation feature is not properly configured.'}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
        
        teleconsultation = self.get_object()
        
        # Check if user is authorized (patient or doctor of this consultation)
        user = request.user
        consultation = teleconsultation.consultation
        if not (user == consultation.patient.user or user == consultation.medecin.user):
            return Response(
                {'error': 'Vous n\'√™tes pas autoris√© √† acc√©der √† cette t√©l√©consultation'}, 
                status=status.HTTP_403_FORBIDDEN
            )
        
        # Get Agora credentials from environment variables
        app_id = os.environ.get('AGORA_APP_ID')
        app_certificate = os.environ.get('AGORA_APP_CERTIFICATE')
        
        # Check if App ID is provided
        if not app_id or app_id == '':
            return Response(
                {'error': 'Agora App ID not configured. Please set AGORA_APP_ID environment variable.'}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
        
        # Check if App Certificate is provided
        if not app_certificate or app_certificate == '' or app_certificate == 'your_agora_app_certificate_here':
            return Response(
                {'error': 'Agora App Certificate not configured. Please set AGORA_APP_CERTIFICATE environment variable for secure authentication.'}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
        
        # Generate secure token with certificate
        channel_name = teleconsultation.channel_name
        uid = 0  # Using 0 as uid for simplicity
        role = 1  # Publisher role
        expire_time_in_seconds = 3600  # 1 hour
        current_timestamp = int(time.time())
        privilege_expired_ts = current_timestamp + expire_time_in_seconds
        
        try:
            token = RtcTokenBuilder.buildTokenWithUid(
                app_id, app_certificate, channel_name, uid, role, privilege_expired_ts
            )
            
            return Response({
                'token': token,
                'channel_name': channel_name,
                'uid': uid
            })
        except Exception as e:
            return Response(
                {'error': f'Error generating token: {str(e)}'}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
    
    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def end(self, request, pk=None):
        """End a teleconsultation"""
        teleconsultation = self.get_object()
        user = request.user
        consultation = teleconsultation.consultation
        
        # Check if user is authorized (patient or doctor of this consultation)
        if not (user == consultation.patient.user or user == consultation.medecin.user):
            return Response(
                {'error': 'Vous n\'√™tes pas autoris√© √† terminer cette t√©l√©consultation'}, 
                status=status.HTTP_403_FORBIDDEN
            )
        
        # Update teleconsultation end time
        teleconsultation.ended_at = timezone.now()
        teleconsultation.save()
        
        # Also end the consultation
        consultation.statut = 'terminee'
        consultation.save()
        
        return Response({
            'message': 'T√©l√©consultation termin√©e avec succ√®s',
            'teleconsultation': TeleconsultationSerializer(teleconsultation).data
        })


# -------------------- Disponibilit√© M√©decin --------------------
class DisponibiliteMedecinViewSet(viewsets.ModelViewSet):
    queryset = DisponibiliteMedecin.objects.all()
    serializer_class = DisponibiliteMedecinSerializer
    permission_classes = [IsAuthenticated]
    
    def get_queryset(self):
        user = self.request.user
        if user.is_authenticated and user.role == 'medecin':
            try:
                medecin = Medecin.objects.get(user=user)
                return DisponibiliteMedecin.objects.filter(medecin=medecin)
            except Medecin.DoesNotExist:
                return DisponibiliteMedecin.objects.none()
        return DisponibiliteMedecin.objects.none()
    
    def perform_create(self, serializer):
        # Auto-assign medecin from authenticated user
        user = self.request.user
        try:
            medecin = Medecin.objects.get(user=user)
            serializer.save(medecin=medecin)
        except Medecin.DoesNotExist:
            raise serializers.ValidationError("Profil m√©decin non trouv√©")
    
    @action(detail=False, methods=['get'], permission_classes=[IsAuthenticated])
    def mes_disponibilites(self, request):
        """
        Get all disponibilities for the current doctor
        """
        user = self.request.user
        try:
            medecin = Medecin.objects.get(user=user)
            disponibilites = DisponibiliteMedecin.objects.filter(medecin=medecin)
            serializer = self.get_serializer(disponibilites, many=True)
            return Response(serializer.data)
        except Medecin.DoesNotExist:
            return Response({'error': 'Profil m√©decin non trouv√©'}, status=status.HTTP_404_NOT_FOUND)
    
    @action(detail=False, methods=['post'], permission_classes=[IsAuthenticated])
    def ajouter_disponibilite(self, request):
        """
        Add a new disponibility for the current doctor
        """
        return self.create(request)


class IndisponibiliteMedecinViewSet(viewsets.ModelViewSet):
    queryset = IndisponibiliteMedecin.objects.all()
    serializer_class = IndisponibiliteMedecinSerializer
    permission_classes = [IsAuthenticated]
    
    def get_queryset(self):
        user = self.request.user
        if user.is_authenticated and user.role == 'medecin':
            try:
                medecin = Medecin.objects.get(user=user)
                return IndisponibiliteMedecin.objects.filter(medecin=medecin)
            except Medecin.DoesNotExist:
                return IndisponibiliteMedecin.objects.none()
        return IndisponibiliteMedecin.objects.none()
    
    def perform_create(self, serializer):
        # Auto-assign medecin from authenticated user
        user = self.request.user
        try:
            medecin = Medecin.objects.get(user=user)
            serializer.save(medecin=medecin)
        except Medecin.DoesNotExist:
            raise serializers.ValidationError("Profil m√©decin non trouv√©")
    
    @action(detail=False, methods=['get'], permission_classes=[IsAuthenticated])
    def mes_indisponibilites(self, request):
        """
        Get all unavailabilities for the current doctor
        """
        user = self.request.user
        try:
            medecin = Medecin.objects.get(user=user)
            indisponibilites = IndisponibiliteMedecin.objects.filter(medecin=medecin)
            serializer = self.get_serializer(indisponibilites, many=True)
            return Response(serializer.data)
        except Medecin.DoesNotExist:
            return Response({'error': 'Profil m√©decin non trouv√©'}, status=status.HTTP_404_NOT_FOUND)
    
    @action(detail=False, methods=['post'], permission_classes=[IsAuthenticated])
    def ajouter_indisponibilite(self, request):
        """
        Add a new unavailability for the current doctor
        """
        return self.create(request)

# --------------------
# M√©dicaments
# --------------------
class MedicamentViewSet(viewsets.ModelViewSet):
    queryset = Medicament.objects.all()
    serializer_class = MedicamentSerializer

    def get_queryset(self):
        return Medicament.objects.all()

    def get_permissions(self):
        if self.action in ['list', 'retrieve']:
            return [AllowAny()]
        return [IsAuthenticated()]

# --------------------
# Pathologies
# --------------------
class PathologieViewSet(viewsets.ModelViewSet):
    queryset = Pathologie.objects.all()
    serializer_class = PathologieSerializer

    def get_queryset(self):
        return Pathologie.objects.all()

    def get_permissions(self):
        if self.action in ['list', 'retrieve']:
            return [AllowAny()]
        return [IsAuthenticated()]

# --------------------
# Traitements
# --------------------
class TraitementViewSet(viewsets.ModelViewSet):
    queryset = Traitement.objects.all()
    serializer_class = TraitementSerializer

    def get_queryset(self):
        return Traitement.objects.all()

    def get_permissions(self):
        if self.action in ['list', 'retrieve']:
            return [AllowAny()]
        return [IsAuthenticated()]

# --------------------
# Constantes
# --------------------
class ConstanteViewSet(viewsets.ModelViewSet):
    queryset = Constante.objects.all()
    serializer_class = ConstanteSerializer

    def get_queryset(self):
        return Constante.objects.all()

    def get_permissions(self):
        if self.action in ['list', 'retrieve']:
            return [AllowAny()]
        return [IsAuthenticated()]

# --------------------
# Mesures
# --------------------
class MesureViewSet(viewsets.ModelViewSet):
    queryset = Mesure.objects.all()
    serializer_class = MesureSerializer

    def get_queryset(self):
        return Mesure.objects.all()

    def get_permissions(self):
        if self.action in ['list', 'retrieve']:
            return [AllowAny()]
        return [IsAuthenticated()]

# --------------------
# Articles
# --------------------
class ArticleViewSet(viewsets.ModelViewSet):
    queryset = Article.objects.all()
    serializer_class = ArticleSerializer

    def get_queryset(self):
        return Article.objects.all()

    def get_permissions(self):
        if self.action in ['list', 'retrieve']:
            return [AllowAny()]
        return [IsAuthenticated()]

# --------------------
# Structures de sant√©
# --------------------
class StructureDeSanteViewSet(viewsets.ModelViewSet):
    queryset = StructureDeSante.objects.all()
    serializer_class = StructureDeSanteSerializer

    def get_queryset(self):
        return StructureDeSante.objects.all()

    def get_permissions(self):
        if self.action in ['list', 'retrieve']:
            return [AllowAny()]
        return [IsAuthenticated()]

# --------------------
# Services
# --------------------
class ServiceViewSet(viewsets.ModelViewSet):
    queryset = Service.objects.all()
    serializer_class = ServiceSerializer

    def get_queryset(self):
        return Service.objects.all()

    def get_permissions(self):
        if self.action in ['list', 'retrieve']:
            return [AllowAny()]
        return [IsAuthenticated()]
    
class CliniqueViewSet(viewsets.ModelViewSet):
    queryset = Clinique.objects.all()
    serializer_class = CliniqueSerializer
    permission_classes = [AllowAny]


class DentisteViewSet(viewsets.ModelViewSet):
    queryset = Dentiste.objects.all()
    serializer_class = DentisteSerializer
    permission_classes = [AllowAny]


class HopitalViewSet(viewsets.ModelViewSet):
    queryset = Hopital.objects.all()
    serializer_class = HopitalSerializer
    permission_classes = [AllowAny]


class PharmacieViewSet(viewsets.ModelViewSet):
    queryset = Pharmacie.objects.all()
    serializer_class = PharmacieSerializer
    permission_classes = [AllowAny]


class ContactFooterViewSet(viewsets.ModelViewSet):
    queryset = ContactFooter.objects.all()
    serializer_class = ContactFooterSerializer
    permission_classes = [AllowAny]


# -------------------- Medical Documents --------------------
class MedicalDocumentViewSet(viewsets.ModelViewSet):
    queryset = MedicalDocument.objects.all()
    serializer_class = MedicalDocumentSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if user.role == 'medecin':
            # Doctors can see documents for their appointments
            return MedicalDocument.objects.filter(
                rendez_vous__medecin=user
            )
        else:
            # Patients can see documents they uploaded or that were shared with them
            return MedicalDocument.objects.filter(
                Q(uploaded_by=user) | Q(rendez_vous__patient=user)
            )

    def perform_create(self, serializer):
        # Save the appointment
        appointment = serializer.save()
        
        # Send notification to the doctor
        from .notifications import NotificationService
        try:
            # Additional validation to ensure we're only sending to one specific doctor
            if hasattr(appointment, 'medecin') and appointment.medecin and hasattr(appointment.medecin, 'user'):
                NotificationService.send_appointment_request_notification(appointment)
            else:
                print(f"‚ùå Erreur: Aucun m√©decin associ√© au rendez-vous {getattr(appointment, 'numero', 'N/A')}")
        except Exception as e:
            print(f"Error sending appointment notification: {e}")

# --------------------
# Chatbot (Rasa)
# --------------------
class ChatbotAPIView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        message = request.data.get("message", "")
        if not message:
            return Response({"error": "Aucun message fourni"}, status=400)

        # Get or create patient profile
        try:
            patient = request.user.patient_profile
        except Patient.DoesNotExist:
            return Response({"error": "Profil patient non trouv√©"}, status=400)

        rasa_url = "http://localhost:5005/webhooks/rest/webhook"
        payload = {
            "sender": str(request.user.id),
            "message": message
        }

        try:
            response = requests.post(rasa_url, json=payload)
            response_data = response.json()
            
            # Extract bot response
            bot_response = ""
            if response_data and isinstance(response_data, list) and len(response_data) > 0:
                bot_response = response_data[0].get("text", "D√©sol√©, je n'ai pas compris.")
            else:
                bot_response = "D√©sol√©, je n'ai pas compris."
            
            # Save conversation to database
            conversation = ChatbotConversation.objects.create(
                patient=patient,
                message_user=message,
                message_bot=bot_response
            )
            
            return Response({"responses": response_data})
        except Exception as e:
            return Response({"error": str(e)}, status=500)
            
    def get(self, request):
        """Get chatbot conversation history for the authenticated patient"""
        try:
            patient = request.user.patient_profile
            conversations = ChatbotConversation.objects.filter(patient=patient).order_by('timestamp')
            serializer = ChatbotConversationSerializer(conversations, many=True)
            return Response(serializer.data)
        except Patient.DoesNotExist:
            return Response({"error": "Profil patient non trouv√©"}, status=400)
        except Exception as e:
            return Response({"error": str(e)}, status=500)


User = get_user_model()

# Inscription
class RegisterView(APIView):
    permission_classes = [AllowAny]

    def post(self, request):
        data = request.data.copy()

        # Emp√™cher l'inscription en tant qu'admin via frontend
        if data.get("role") == "admin":
            return Response(
                {"error": "Vous ne pouvez pas vous inscrire en tant qu'administrateur."},
                status=status.HTTP_400_BAD_REQUEST
            )

        # Par d√©faut "patient" si non sp√©cifi√©
        if not data.get("role"):
            data["role"] = "patient"

        serializer = RegisterSerializer(data=data)
        if serializer.is_valid():
            try:
                user = serializer.save()  # üîπ Profil Patient/Medecin cr√©√© automatiquement par signals
                
                # Send welcome email
                
                return Response({
                    'message': 'Utilisateur enregistr√© avec succ√®s',
                    'user': {
                        'id': user.id,
                        'username': user.username,
                        'email': user.email,
                        'first_name': user.first_name,
                        'last_name': user.last_name,
                        'role': user.role
                    }
                }, status=status.HTTP_201_CREATED)
            except Exception as e:
                logger.error(f"Erreur lors de la cr√©ation de l'utilisateur: {str(e)}")
                return Response(
                    {'error': 'Erreur lors de la cr√©ation de l\'utilisateur'}, 
                    status=status.HTTP_500_INTERNAL_SERVER_ERROR
                )


# --------------------
# Connexion
# --------------------
class LoginView(APIView):
    permission_classes = [AllowAny]

    def post(self, request):
        try:
            username = request.data.get('username')
            password = request.data.get('password')
            
            logger.info(f"Tentative de connexion pour: {username}")
            
            if not username or not password:
                return Response(
                    {'error': 'Le nom d\'utilisateur et le mot de passe sont requis'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            # Authentifier l'utilisateur
            user = authenticate(username=username, password=password)
            
            if user is None:
                logger.warning(f"√âchec d'authentification pour: {username}")
                return Response(
                    {'error': 'Identifiants incorrects'},
                    status=status.HTTP_401_UNAUTHORIZED
                )
            
            if not user.is_active:
                return Response(
                    {'error': 'Ce compte est d√©sactiv√©. Veuillez contacter l\'administrateur.'},
                    status=status.HTTP_403_FORBIDDEN
                )
            
            # G√©n√©rer les tokens JWT
            refresh = RefreshToken.for_user(user)
            
            # R√©cup√©rer le profil selon le r√¥le
            profile_data = None
            if hasattr(user, 'patient_profile'):
                profile_data = {
                    'id': user.patient_profile.id,
                    'adresse': getattr(user.patient_profile, 'adresse', '')
                }
            elif hasattr(user, 'medecin_profile'):
                profile_data = {
                    'id': user.medecin_profile.id,
                    'specialite': getattr(user.medecin_profile, 'specialite', '')
                }
            
            logger.info(f"Connexion r√©ussie pour: {username}")
            
            return Response({
                'access': str(refresh.access_token),
                'refresh': str(refresh),
                'user': {
                    'id': user.id,
                    'username': user.username,
                    'email': getattr(user, 'email', ''),
                    'first_name': getattr(user, 'first_name', ''),
                    'last_name': getattr(user, 'last_name', ''),
                    'role': getattr(user, 'role', 'patient'),
                    'is_active': user.is_active,
                    'profile': profile_data
                }
            }, status=status.HTTP_200_OK)
            
        except Exception as e:
            logger.error(f"Erreur lors de la connexion: {str(e)}", exc_info=True)
            return Response(
                {'error': 'Erreur serveur lors de la connexion. Veuillez r√©essayer plus tard.'},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


@api_view(["GET"])
@permission_classes([IsAuthenticated])
def upcoming_appointments(request):
    patient = request.user  # on suppose que user = patient
    today = now().date()

    rdvs = RendezVous.objects.filter(
        patient=patient,
        date__gte=today
    ).exclude(
        statut__in=["CANCELLED", "TERMINE"]
    ).order_by("date", "heure")

    serializer = RendezVousSerializer(rdvs, many=True)
    return Response(serializer.data)


@api_view(["GET"])
@permission_classes([IsAuthenticated])
def patient_medications(request):
    """R√©cup√©rer les rappels de m√©dicaments du patient (avec audit)"""
    try:
        patient = Patient.objects.get(user=request.user)
        
        # LOG D'AUDIT
        log_action(
            user=request.user,
            action='read',
            model_name='MedicationReminders',
            object_id=patient.id,
            details={'patient': patient.user.username},
            request=request
        )
        
        rappels = RappelMedicament.objects.filter(patient=patient, actif=True)
        serializer = RappelMedicamentSerializer(rappels, many=True)
        return Response(serializer.data)
    except Patient.DoesNotExist:
        return Response({'error': 'Patient non trouv√©'}, status=404)


@api_view(["POST"])
@permission_classes([IsAuthenticated])
def cancel_appointment(request, pk):
    rdv = get_object_or_404(RendezVous, pk=pk, patient=request.user)
    old_status = rdv.statut
    rdv.statut = "CANCELLED"
    rdv.save()
    
    # Send cancellation notification
    if old_status != "CANCELLED":
        NotificationService.send_appointment_cancellation(rdv)
    
    return Response({"message": "Rendez-vous annul√© avec succ√®s"}, status=status.HTTP_200_OK)


@api_view(["POST"])
@permission_classes([IsAuthenticated])
def reschedule_appointment(request, pk):
    rdv = get_object_or_404(RendezVous, pk=pk, patient=request.user)
    new_date = request.data.get("date")
    new_heure = request.data.get("heure")

    if not new_date or not new_heure:
        return Response({"error": "Veuillez fournir une nouvelle date et heure"},
                        status=status.HTTP_400_BAD_REQUEST)

    # Store old values for notification
    old_date = rdv.date
    old_heure = rdv.heure

    rdv.date = new_date
    rdv.heure = new_heure
    old_status = rdv.statut
    rdv.statut = "RESCHEDULED"
    rdv.save()

    # Send reschedule notification
    if old_status != "RESCHEDULED":
        NotificationService.send_appointment_reschedule(rdv, old_date, old_heure)

    return Response({"message": "Rendez-vous reprogramm√© avec succ√®s"}, status=status.HTTP_200_OK)


@api_view(["POST"])
@permission_classes([IsAuthenticated])
def doctor_reschedule_appointment(request, pk):
    """Doctor reschedules an appointment and notifies the patient"""
    try:
        # Get the appointment - doctors can reschedule any appointment
        rdv = get_object_or_404(RendezVous, pk=pk)
        
        # Check if the user is a doctor
        if request.user.role != 'medecin':
            return Response({"error": "Seuls les m√©decins peuvent reprogrammer les rendez-vous"}, 
                          status=status.HTTP_403_FORBIDDEN)
        
        # Get new date and time from request
        new_date = request.data.get("date")
        new_heure = request.data.get("heure")
        description = request.data.get("description", "")
        
        if not new_date or not new_heure:
            return Response({"error": "Veuillez fournir une nouvelle date et heure"},
                          status=status.HTTP_400_BAD_REQUEST)
        
        # Store original values for notification
        old_date = rdv.date
        old_heure = rdv.heure
        old_status = rdv.statut
        
        # Update appointment with new date/time
        rdv.date = new_date
        rdv.heure = new_heure
        rdv.description = description
        rdv.statut = "RESCHEDULED"
        
        # Store original date/time if not already stored
        if not rdv.original_date:
            rdv.original_date = old_date
            rdv.original_heure = old_heure
            
        rdv.save()
        
        # Send notification to patient about the rescheduling
        NotificationService.send_appointment_reschedule(rdv, old_date, old_heure)
        
        serializer = RendezVousSerializer(rdv)
        return Response(serializer.data, status=status.HTTP_200_OK)
        
    except RendezVous.DoesNotExist:
        return Response({"error": "Rendez-vous non trouv√©"}, status=status.HTTP_404_NOT_FOUND)
    except Exception as e:
        return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

# --------------------
# Medication Reminder APIs
# --------------------
@api_view(['GET', 'POST'])
@permission_classes([IsAuthenticated])
def medication_reminders(request):
    """Get or create medication reminders for the authenticated patient"""
    try:
        patient = request.user.patient_profile
    except Patient.DoesNotExist:
        return Response({"error": "Profil patient non trouv√©"}, status=status.HTTP_400_BAD_REQUEST)
    
    if request.method == 'GET':
        # Get all medication reminders for the patient
        reminders = RappelMedicament.objects.filter(patient=patient).order_by('heure_rappel')
        serializer = RappelMedicamentSerializer(reminders, many=True)
        return Response(serializer.data)
    
    elif request.method == 'POST':
        # Create a new medication reminder
        serializer = RappelMedicamentSerializer(data=request.data, context={'request': request})
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


@api_view(['GET', 'PUT', 'DELETE'])
@permission_classes([IsAuthenticated])
def medication_reminder_detail(request, pk):
    """Get, update, or delete a specific medication reminder"""
    try:
        patient = request.user.patient_profile
        reminder = get_object_or_404(RappelMedicament, pk=pk, patient=patient)
    except Patient.DoesNotExist:
        return Response({"error": "Profil patient non trouv√©"}, status=status.HTTP_400_BAD_REQUEST)
    
    if request.method == 'GET':
        serializer = RappelMedicamentSerializer(reminder)
        return Response(serializer.data)
    
    elif request.method == 'PUT':
        serializer = RappelMedicamentSerializer(reminder, data=request.data, partial=True)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
    elif request.method == 'DELETE':
        reminder.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def medication_history(request):
    """Get medication history for the authenticated patient"""
    try:
        patient = request.user.patient_profile
    except Patient.DoesNotExist:
        return Response({"error": "Profil patient non trouv√©"}, status=status.HTTP_400_BAD_REQUEST)
    
    # Get all medication history for the patient
    history = HistoriquePriseMedicament.objects.filter(
        rappel__patient=patient
    ).select_related('rappel').order_by('-date_prise')
    
    serializer = HistoriquePriseMedicamentSerializer(history, many=True)
    return Response(serializer.data)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def mark_medication_taken(request, pk):
    """Mark a medication as taken"""
    try:
        patient = request.user.patient_profile
        history_entry = get_object_or_404(HistoriquePriseMedicament, pk=pk, rappel__patient=patient)
    except Patient.DoesNotExist:
        return Response({"error": "Profil patient non trouv√©"}, status=status.HTTP_400_BAD_REQUEST)
    
    # Update the history entry
    history_entry.prise_effectuee = True
    history_entry.notes = request.data.get('notes', 'Pris par le patient')
    history_entry.save()
    
    serializer = HistoriquePriseMedicamentSerializer(history_entry)
    return Response(serializer.data)

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def admin_statistics(request):
    """Statistiques pour le dashboard admin"""
    # V√©rifier que l'utilisateur est admin
    if request.user.role != 'admin':
        return Response({'error': 'Acc√®s non autoris√©'}, status=403)

    today = date.today()
    week_ago = today - timedelta(days=7)
    month_ago = today - timedelta(days=30)

    stats = {
        'total_users': User.objects.count(),
        'total_patients': Patient.objects.count(),
        'total_medecins': Medecin.objects.count(),
        'total_rendez_vous': RendezVous.objects.count(),
        'rendez_vous_today': RendezVous.objects.filter(date=today).count(),
        'rendez_vous_week': RendezVous.objects.filter(date__gte=week_ago).count(),
        'rendez_vous_month': RendezVous.objects.filter(date__gte=month_ago).count(),
        'rendez_vous_by_status': RendezVous.objects.values('statut').annotate(count=Count('id')),
        'new_users_week': User.objects.filter(date_joined__gte=week_ago).count(),
        'new_users_month': User.objects.filter(date_joined__gte=month_ago).count(),
        'total_consultations': Consultation.objects.count(),
        'total_pathologies': Pathologie.objects.count(),
        'total_medicaments': Medicament.objects.count(),
    }

    return Response(stats)

# ========== ARTICLES PUBLICS ==========

@api_view(['GET'])
def articles_publics(request):
    """Liste des articles valid√©s (acc√®s public) avec pagination"""
    articles = Article.objects.filter(statut='valide').order_by('-date_publication')

    # Filtres optionnels
    categorie = request.GET.get('categorie')
    search = request.GET.get('search')

    if categorie and categorie != 'all':
        articles = articles.filter(categorie=categorie)

    if search:
        from django.db.models import Q
        articles = articles.filter(
            Q(titre__icontains=search) |
            Q(contenu__icontains=search) |
            Q(tags__icontains=search) |
            Q(resume__icontains=search)
        )

    # Pagination
    from rest_framework.pagination import PageNumberPagination
    paginator = PageNumberPagination()
    paginator.page_size = 12  # Articles per page
    paginator.page_size_query_param = 'page_size'
    paginator.max_page_size = 100
    
    result_page = paginator.paginate_queryset(articles, request)
    serializer = ArticleListSerializer(result_page, many=True)
    return paginator.get_paginated_response(serializer.data)


@api_view(['GET'])
def article_detail_public(request, slug):
    """D√©tail d'un article public"""
    try:
        article = Article.objects.get(slug=slug, statut='valide')
        article.incrementer_vues()
        serializer = ArticleSerializer(article, context={'request': request})
        return Response(serializer.data)
    except Article.DoesNotExist:
        return Response({'error': 'Article non trouv√©'}, status=404)


# ========== ARTICLES M√âDECINS ==========

@api_view(['GET', 'POST'])
@permission_classes([IsAuthenticated])
def articles_medecin(request):
    """Gestion des articles par les m√©decins"""
    if request.user.role != 'medecin':
        return Response({'error': 'Acc√®s r√©serv√© aux m√©decins'}, status=403)

    try:
        medecin = Medecin.objects.get(user=request.user)
    except Medecin.DoesNotExist:
        return Response({'error': 'Profil m√©decin non trouv√©'}, status=404)

    if request.method == 'GET':
        # R√©cup√©rer tous les articles du m√©decin
        statut = request.GET.get('statut', 'all')
        articles = Article.objects.filter(auteur=medecin)

        if statut != 'all':
            articles = articles.filter(statut=statut)

        articles = articles.order_by('-date_modification')
        serializer = ArticleListSerializer(articles, many=True)
        return Response(serializer.data)

    elif request.method == 'POST':
        # Cr√©er un nouvel article
        data = request.data.copy()
        data['auteur'] = medecin.id  # Set the author to the current doctor

        serializer = ArticleSerializer(data=data, context={'request': request})
        if serializer.is_valid():
            article = serializer.save()
            return Response(ArticleSerializer(article, context={'request': request}).data, status=201)
        return Response(serializer.errors, status=400)


@api_view(['GET', 'PUT', 'DELETE'])
@permission_classes([IsAuthenticated])
def article_medecin_detail(request, pk):
    """D√©tail/modification/suppression d'un article par le m√©decin"""
    if request.user.role != 'medecin':
        return Response({'error': 'Acc√®s r√©serv√© aux m√©decins'}, status=403)

    try:
        medecin = Medecin.objects.get(user=request.user)
        article = Article.objects.get(pk=pk, auteur=medecin)
    except Medecin.DoesNotExist:
        return Response({'error': 'Profil m√©decin non trouv√©'}, status=404)
    except Article.DoesNotExist:
        return Response({'error': 'Article non trouv√© ou non autoris√©'}, status=404)

    if request.method == 'GET':
        serializer = ArticleSerializer(article, context={'request': request})
        return Response(serializer.data)

    elif request.method == 'PUT':
        if article.statut not in ['brouillon', 'refuse']:
            return Response({'error': 'Seuls les brouillons et articles refus√©s peuvent √™tre modifi√©s'}, status=400)

        serializer = ArticleSerializer(article, data=request.data, partial=True, context={'request': request})
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=400)

    elif request.method == 'DELETE':
        if article.statut != 'brouillon':
            return Response({'error': 'Seuls les brouillons peuvent √™tre supprim√©s'}, status=400)
        article.delete()
        return Response({'message': 'Article supprim√© avec succ√®s'}, status=204)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def article_soumettre_validation(request, pk):
    """Soumettre un article pour validation par l'admin"""
    if request.user.role != 'medecin':
        return Response({'error': 'Acc√®s r√©serv√© aux m√©decins'}, status=403)

    try:
        medecin = Medecin.objects.get(user=request.user)
        article = Article.objects.get(pk=pk, auteur=medecin)
    except Article.DoesNotExist:
        return Response({'error': 'Article non trouv√©'}, status=404)

    if article.statut not in ['brouillon', 'refuse']:
        return Response({'error': 'Cet article ne peut pas √™tre soumis'}, status=400)

    # V√©rifier que les champs obligatoires sont remplis
    if not article.titre or not article.contenu or not article.resume:
        return Response({'error': 'Veuillez remplir tous les champs obligatoires'}, status=400)

    article.statut = 'en_attente'
    article.save()

    return Response({
        'message': 'Article soumis pour validation avec succ√®s',
        'statut': article.statut
    })


# ========== ARTICLES ADMIN (Mod√©ration) ==========

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def articles_admin_list(request):
    """Liste de tous les articles pour mod√©ration (admin uniquement)"""
    if request.user.role != 'admin':
        return Response({'error': 'Acc√®s r√©serv√© aux administrateurs'}, status=403)

    statut = request.GET.get('statut', 'all')
    articles = Article.objects.all().order_by('-date_modification')

    if statut != 'all':
        articles = articles.filter(statut=statut)

    serializer = ArticleListSerializer(articles, many=True)
    return Response(serializer.data)


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def article_admin_detail(request, pk):
    """D√©tail d'un article pour mod√©ration"""
    if request.user.role != 'admin':
        return Response({'error': 'Acc√®s r√©serv√© aux administrateurs'}, status=403)

    try:
        article = Article.objects.get(pk=pk)
        serializer = ArticleSerializer(article, context={'request': request})
        return Response(serializer.data)
    except Article.DoesNotExist:
        return Response({'error': 'Article non trouv√©'}, status=404)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def article_valider(request, pk):
    """Valider un article (admin)"""
    if request.user.role != 'admin':
        return Response({'error': 'Acc√®s r√©serv√© aux administrateurs'}, status=403)

    try:
        article = Article.objects.get(pk=pk)

        if article.statut not in ['en_attente', 'refuse', 'desactive']:
            return Response({'error': 'Cet article ne peut pas √™tre valid√©'}, status=400)

        article.statut = 'valide'
        article.valide_par = request.user
        from django.utils import timezone
        article.date_validation = timezone.now()
        article.commentaire_moderation = request.data.get('commentaire', '')
        article.save()

        return Response({
            'message': 'Article valid√© avec succ√®s',
            'statut': article.statut
        })
    except Article.DoesNotExist:
        return Response({'error': 'Article non trouv√©'}, status=404)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def article_refuser(request, pk):
    """Refuser un article (admin)"""
    if request.user.role != 'admin':
        return Response({'error': 'Acc√®s r√©serv√© aux administrateurs'}, status=403)

    commentaire = request.data.get('commentaire')
    if not commentaire:
        return Response({'error': 'Le commentaire est obligatoire pour refuser un article'}, status=400)

    try:
        article = Article.objects.get(pk=pk)

        article.statut = 'refuse'
        article.valide_par = request.user
        from django.utils import timezone
        article.date_validation = timezone.now()
        article.commentaire_moderation = commentaire
        article.save()

        return Response({
            'message': 'Article refus√©',
            'statut': article.statut
        })
    except Article.DoesNotExist:
        return Response({'error': 'Article non trouv√©'}, status=404)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def article_desactiver(request, pk):
    """D√©sactiver un article publi√© (admin)"""
    if request.user.role != 'admin':
        return Response({'error': 'Acc√®s r√©serv√© aux administrateurs'}, status=403)

    try:
        article = Article.objects.get(pk=pk)

        if article.statut != 'valide':
            return Response({'error': 'Seuls les articles valid√©s peuvent √™tre d√©sactiv√©s'}, status=400)

        article.statut = 'desactive'
        article.commentaire_moderation = request.data.get('commentaire', 'Article d√©sactiv√©')
        article.save()

        return Response({
            'message': 'Article d√©sactiv√©',
            'statut': article.statut
        })
    except Article.DoesNotExist:
        return Response({'error': 'Article non trouv√©'}, status=404)


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def articles_statistics(request):
    """Statistiques des articles pour le dashboard admin"""
    if request.user.role != 'admin':
        return Response({'error': 'Acc√®s r√©serv√© aux administrateurs'}, status=403)

    from django.db.models import Count, Sum
    stats = {
        'total': Article.objects.count(),
        'brouillons': Article.objects.filter(statut='brouillon').count(),
        'en_attente': Article.objects.filter(statut='en_attente').count(),
        'valides': Article.objects.filter(statut='valide').count(),
        'refuses': Article.objects.filter(statut='refuse').count(),
        'desactives': Article.objects.filter(statut='desactive').count(),
        'total_vues': Article.objects.filter(statut='valide').aggregate(total=Sum('vues'))['total'] or 0,
        'par_categorie': list(Article.objects.filter(statut='valide').values('categorie').annotate(count=Count('id')))
    }

    return Response(stats)

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def admin_users_list(request):
    """Liste tous les utilisateurs pour l'admin"""
    if request.user.role != 'admin':
        return Response({'error': 'Acc√®s non autoris√©'}, status=403)

    users = User.objects.all().order_by('-date_joined')
    data = [{
        'id': user.id,
        'username': user.username,
        'email': user.email,
        'first_name': user.first_name,
        'last_name': user.last_name,
        'role': getattr(user, 'role', 'patient'),  # Default to 'patient' if role not set
        'is_active': user.is_active,
        'date_joined': user.date_joined
    } for user in users]

    return Response(data)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def admin_create_user(request):
    """Cr√©er un nouvel utilisateur par l'admin"""
    if request.user.role != 'admin':
        return Response({'error': 'Acc√®s non autoris√©'}, status=403)

    try:
        # Create user with provided data
        user_data = request.data.copy()
        
        # Check if username already exists
        if User.objects.filter(username=user_data.get('username')).exists():
            return Response({'error': 'Ce nom d\'utilisateur est d√©j√† utilis√©'}, status=400)
            
        # Check if email already exists
        if User.objects.filter(email=user_data.get('email')).exists():
            return Response({'error': 'Cet email est d√©j√† utilis√©'}, status=400)
        
        # Create user
        user = User.objects.create_user(
            username=user_data.get('username'),
            password=user_data.get('password'),
            email=user_data.get('email'),
            first_name=user_data.get('first_name', ''),
            last_name=user_data.get('last_name', ''),
            role=user_data.get('role', 'patient'),
            is_active=user_data.get('is_active', True)
        )
        
        # Create profile based on role
        if user.role == 'patient':
            Patient.objects.get_or_create(user=user, defaults={'adresse': user_data.get('adresse', '')})
        elif user.role == 'medecin':
            Medecin.objects.get_or_create(user=user, defaults={
                'specialite': user_data.get('specialite', 'G√©n√©raliste'),
                'disponibilite': user_data.get('disponibilite', True)
            })
        
        return Response({
            'id': user.id,
            'username': user.username,
            'email': user.email,
            'first_name': user.first_name,
            'last_name': user.last_name,
            'role': user.role,
            'is_active': user.is_active,
            'date_joined': user.date_joined
        }, status=status.HTTP_201_CREATED)
        
    except Exception as e:
        return Response({'error': f'Erreur lors de la cr√©ation de l\'utilisateur: {str(e)}'}, status=400)


@api_view(['PUT'])
@permission_classes([IsAuthenticated])
def admin_update_user(request, user_id):
    """Mettre √† jour un utilisateur par l'admin"""
    if request.user.role != 'admin':
        return Response({'error': 'Acc√®s non autoris√©'}, status=403)

    try:
        user = User.objects.get(id=user_id)
        
        # Prevent admin from modifying another admin
        if user.role == 'admin' and user.id != request.user.id:
            return Response({'error': 'Impossible de modifier un autre administrateur'}, status=400)
        
        # Update user fields
        user_data = request.data
        user.first_name = user_data.get('first_name', user.first_name)
        user.last_name = user_data.get('last_name', user.last_name)
        user.email = user_data.get('email', user.email)
        user.username = user_data.get('username', user.username)
        
        # Only allow role change if it's not an admin
        if user.role != 'admin':
            user.role = user_data.get('role', user.role)
        
        # Update active status
        user.is_active = user_data.get('is_active', user.is_active)
        
        # Save user
        user.save()
        
        # Update profile based on role
        if user.role == 'patient':
            patient, created = Patient.objects.get_or_create(user=user)
            if 'adresse' in user_data:
                patient.adresse = user_data['adresse']
                patient.save()
        elif user.role == 'medecin':
            medecin, created = Medecin.objects.get_or_create(user=user)
            if 'specialite' in user_data:
                medecin.specialite = user_data['specialite']
            if 'disponibilite' in user_data:
                medecin.disponibilite = user_data['disponibilite']
            medecin.save()
        
        return Response({
            'id': user.id,
            'username': user.username,
            'email': user.email,
            'first_name': user.first_name,
            'last_name': user.last_name,
            'role': user.role,
            'is_active': user.is_active,
            'date_joined': user.date_joined
        })
        
    except User.DoesNotExist:
        return Response({'error': 'Utilisateur non trouv√©'}, status=404)
    except Exception as e:
        return Response({'error': f'Erreur lors de la mise √† jour de l\'utilisateur: {str(e)}'}, status=400)


@api_view(['PUT'])
@permission_classes([IsAuthenticated])
def admin_toggle_user_status(request, user_id):
    """Activer/d√©sactiver un utilisateur"""
    if request.user.role != 'admin':
        return Response({'error': 'Acc√®s non autoris√©'}, status=403)

    try:
        user = User.objects.get(id=user_id)
        if user.role == 'admin' and user.id != request.user.id:
            return Response({'error': 'Impossible de modifier un autre administrateur'}, status=400)
        user.is_active = not user.is_active
        user.save()
        return Response({
            'message': f'Utilisateur {"activ√©" if user.is_active else "d√©sactiv√©"}',
            'is_active': user.is_active
        })
    except User.DoesNotExist:
        return Response({'error': 'Utilisateur non trouv√©'}, status=404)


@api_view(['DELETE'])
@permission_classes([IsAuthenticated])
def admin_delete_user(request, user_id):
    """Supprimer un utilisateur"""
    if request.user.role != 'admin':
        return Response({'error': 'Acc√®s non autoris√©'}, status=403)

    try:
        user = User.objects.get(id=user_id)
        if user.role == 'admin':
            return Response({'error': 'Impossible de supprimer un administrateur'}, status=400)
        user.delete()
        return Response({'message': 'Utilisateur supprim√©'}, status=204)
    except User.DoesNotExist:
        return Response({'error': 'Utilisateur non trouv√©'}, status=404)

@api_view(['GET'])
@permission_classes([AllowAny])
def health_facilities(request):
    """Liste de tous les centres de sant√© pour la carte"""
    facilities = []

    # R√©cup√©rer les h√¥pitaux
    hopitaux = Hopital.objects.all()
    for hopital in hopitaux:
        facilities.append({
            'id': f'hopital_{hopital.id}',
            'nom': hopital.nom,
            'type': 'hopital',
            'adresse': getattr(hopital, 'adresse', ''),
            'latitude': float(getattr(hopital, 'latitude', 14.6928)),
            'longitude': float(getattr(hopital, 'longitude', -17.4467)),
            'telephone': getattr(hopital, 'telephone', ''),
            'horaires': getattr(hopital, 'horaires', ''),
        })

    # R√©cup√©rer les cliniques
    cliniques = Clinique.objects.all()
    for clinique in cliniques:
        facilities.append({
            'id': f'clinique_{clinique.id}',
            'nom': clinique.nom,
            'type': 'clinique',
            'adresse': getattr(clinique, 'adresse', ''),
            'latitude': float(getattr(clinique, 'latitude', 14.6928)),
            'longitude': float(getattr(clinique, 'longitude', -17.4467)),
            'telephone': getattr(clinique, 'telephone', ''),
            'horaires': getattr(clinique, 'horaires', ''),
        })

    # R√©cup√©rer les pharmacies
    pharmacies = Pharmacie.objects.all()
    for pharmacie in pharmacies:
        facilities.append({
            'id': f'pharmacie_{pharmacie.id}',
            'nom': pharmacie.nom,
            'type': 'pharmacie',
            'adresse': getattr(pharmacie, 'adresse', ''),
            'latitude': float(getattr(pharmacie, 'latitude', 14.6928)),
            'longitude': float(getattr(pharmacie, 'longitude', -17.4467)),
            'telephone': getattr(pharmacie, 'telephone', ''),
            'horaires': getattr(pharmacie, 'horaires', ''),
        })

    # R√©cup√©rer les dentistes
    dentistes = Dentiste.objects.all()
    for dentiste in dentistes:
        facilities.append({
            'id': f'dentiste_{dentiste.id}',
            'nom': dentiste.nom,
            'type': 'dentiste',
            'adresse': getattr(dentiste, 'adresse', ''),
            'latitude': float(getattr(dentiste, 'latitude', 14.6928)),
            'longitude': float(getattr(dentiste, 'longitude', -17.4467)),
            'telephone': getattr(dentiste, 'telephone', ''),
            'horaires': getattr(dentiste, 'horaires', ''),
        })

    return Response(facilities)


@api_view(['GET'])
@permission_classes([AllowAny])
def nearby_health_facilities(request):
    """Liste des centres de sant√© √† proximit√© d'une position donn√©e"""
    try:
        lat = float(request.GET.get('lat', 14.6937))
        lng = float(request.GET.get('lng', -17.444))
        radius = float(request.GET.get('radius', 10))  # Rayon en km, par d√©faut 10km
    except ValueError:
        return Response({'error': 'Param√®tres de localisation invalides'}, status=400)
    
    # Fonction pour calculer la distance entre deux points (formule de Haversine)
    def calculate_distance(lat1, lon1, lat2, lon2):
        from math import radians, cos, sin, asin, sqrt
        # Convertir les degr√©s en radians
        lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])
        
        # Formule de Haversine
        dlon = lon2 - lon1
        dlat = lat2 - lat1
        a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
        c = 2 * asin(sqrt(a))
        r = 6371  # Rayon de la Terre en km
        return c * r
    
    # R√©cup√©rer tous les centres de sant√©
    facilities = []
    
    # R√©cup√©rer les h√¥pitaux
    hopitaux = Hopital.objects.all()
    for hopital in hopitaux:
        if hopital.latitude and hopital.longitude:
            distance = calculate_distance(lat, lng, float(hopital.latitude), float(hopital.longitude))
            if distance <= radius:
                facilities.append({
                    'id': f'hopital_{hopital.id}',
                    'nom': hopital.nom,
                    'type': 'hopital',
                    'adresse': getattr(hopital, 'adresse', ''),
                    'latitude': float(hopital.latitude),
                    'longitude': float(hopital.longitude),
                    'telephone': getattr(hopital, 'telephone', ''),
                    'horaires': getattr(hopital, 'horaires', ''),
                    'distance': round(distance, 2)
                })

    # R√©cup√©rer les cliniques
    cliniques = Clinique.objects.all()
    for clinique in cliniques:
        if clinique.latitude and clinique.longitude:
            distance = calculate_distance(lat, lng, float(clinique.latitude), float(clinique.longitude))
            if distance <= radius:
                facilities.append({
                    'id': f'clinique_{clinique.id}',
                    'nom': clinique.nom,
                    'type': 'clinique',
                    'adresse': getattr(clinique, 'adresse', ''),
                    'latitude': float(clinique.latitude),
                    'longitude': float(clinique.longitude),
                    'telephone': getattr(clinique, 'telephone', ''),
                    'horaires': getattr(clinique, 'horaires', ''),
                    'distance': round(distance, 2)
                })

    # R√©cup√©rer les pharmacies
    pharmacies = Pharmacie.objects.all()
    for pharmacie in pharmacies:
        if pharmacie.latitude and pharmacie.longitude:
            distance = calculate_distance(lat, lng, float(pharmacie.latitude), float(pharmacie.longitude))
            if distance <= radius:
                facilities.append({
                    'id': f'pharmacie_{pharmacie.id}',
                    'nom': pharmacie.nom,
                    'type': 'pharmacie',
                    'adresse': getattr(pharmacie, 'adresse', ''),
                    'latitude': float(pharmacie.latitude),
                    'longitude': float(pharmacie.longitude),
                    'telephone': getattr(pharmacie, 'telephone', ''),
                    'horaires': getattr(pharmacie, 'horaires', ''),
                    'distance': round(distance, 2)
                })

    # R√©cup√©rer les dentistes
    dentistes = Dentiste.objects.all()
    for dentiste in dentistes:
        if dentiste.latitude and dentiste.longitude:
            distance = calculate_distance(lat, lng, float(dentiste.latitude), float(dentiste.longitude))
            if distance <= radius:
                facilities.append({
                    'id': f'dentiste_{dentiste.id}',
                    'nom': dentiste.nom,
                    'type': 'dentiste',
                    'adresse': getattr(dentiste, 'adresse', ''),
                    'latitude': float(dentiste.latitude),
                    'longitude': float(dentiste.longitude),
                    'telephone': getattr(dentiste, 'telephone', ''),
                    'horaires': getattr(dentiste, 'horaires', ''),
                    'distance': round(distance, 2)
                })
    
    # Trier par distance
    facilities.sort(key=lambda x: x['distance'])
    
    return Response(facilities)

# ========== URGENCES PATIENT ==========

@api_view(['GET', 'POST'])
@permission_classes([IsAuthenticated])
def urgences_patient(request):
    """Gestion des urgences pour les patients"""
    if request.user.role != 'patient':
        return Response({'error': 'Acc√®s r√©serv√© aux patients'}, status=403)

    try:
        patient = Patient.objects.get(user=request.user)
    except Patient.DoesNotExist:
        return Response({'error': 'Profil patient non trouv√©'}, status=404)

    if request.method == 'GET':
        urgences = Urgence.objects.filter(patient=patient).order_by('-date_creation')
        serializer = UrgenceSerializer(urgences, many=True)
        return Response(serializer.data)

    elif request.method == 'POST':
        data = request.data.copy()
        data['patient'] = patient.id

        serializer = UrgenceSerializer(data=data)
        if serializer.is_valid():
            urgence = serializer.save()

            # Envoyer notifications aux m√©decins disponibles
            notifier_medecins_urgence(urgence)

            # Envoyer email au patient
            from .notifications import NotificationService
            NotificationService.send_urgence_confirmation(urgence)

            return Response(UrgenceSerializer(urgence).data, status=201)
        return Response(serializer.errors, status=400)


def notifier_medecins_urgence(urgence):
    """Envoyer des notifications aux m√©decins disponibles"""
    # R√©cup√©rer les m√©decins disponibles (vous pouvez affiner la logique)
    medecins = Medecin.objects.filter(disponibilite='disponible')[:5]  # Top 5

    for medecin in medecins:
        NotificationUrgence.objects.create(
            urgence=urgence,
            medecin=medecin
        )

        # Envoyer email au m√©decin
        from .notifications import NotificationService
        NotificationService.send_urgence_notification_medecin(urgence, medecin)


# ========== URGENCES M√âDECIN ==========

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def urgences_medecin(request):
    """Liste des urgences pour les m√©decins"""
    if request.user.role != 'medecin':
        return Response({'error': 'Acc√®s r√©serv√© aux m√©decins'}, status=403)

    try:
        medecin = Medecin.objects.get(user=request.user)
    except Medecin.DoesNotExist:
        return Response({'error': 'Profil m√©decin non trouv√©'}, status=404)

    statut = request.GET.get('statut', 'en_attente')

    if statut == 'mes_prises_en_charge':
        urgences = Urgence.objects.filter(medecin_charge=medecin)
    else:
        urgences = Urgence.objects.filter(statut=statut)

    urgences = urgences.order_by('-priorite', '-date_creation')
    serializer = UrgenceSerializer(urgences, many=True)
    return Response(serializer.data)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def urgence_prendre_en_charge(request, pk):
    """Prendre en charge une urgence"""
    if request.user.role != 'medecin':
        return Response({'error': 'Acc√®s r√©serv√© aux m√©decins'}, status=403)

    try:
        medecin = Medecin.objects.get(user=request.user)
        urgence = Urgence.objects.get(pk=pk)
    except Medecin.DoesNotExist:
        return Response({'error': 'Profil m√©decin non trouv√©'}, status=404)
    except Urgence.DoesNotExist:
        return Response({'error': 'Urgence non trouv√©e'}, status=404)

    if urgence.statut != 'en_attente':
        return Response({'error': 'Cette urgence a d√©j√† √©t√© prise en charge'}, status=400)

    urgence.statut = 'prise_en_charge'
    urgence.medecin_charge = medecin
    urgence.date_prise_en_charge = timezone.now()
    urgence.save()

    # Notifier le patient
    from .notifications import NotificationService
    NotificationService.send_urgence_prise_en_charge(urgence)

    return Response({
        'message': 'Urgence prise en charge',
        'urgence': UrgenceSerializer(urgence).data
    })


@api_view(['PUT'])
@permission_classes([IsAuthenticated])
def urgence_resoudre(request, pk):
    """Marquer une urgence comme r√©solue"""
    if request.user.role != 'medecin':
        return Response({'error': 'Acc√®s r√©serv√© aux m√©decins'}, status=403)

    try:
        medecin = Medecin.objects.get(user=request.user)
        urgence = Urgence.objects.get(pk=pk, medecin_charge=medecin)
    except Urgence.DoesNotExist:
        return Response({'error': 'Urgence non trouv√©e ou non autoris√©e'}, status=404)

    urgence.statut = 'resolue'
    urgence.notes_medecin = request.data.get('notes', '')
    urgence.save()

    return Response({
        'message': 'Urgence marqu√©e comme r√©solue',
        'urgence': UrgenceSerializer(urgence).data
    })


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def notifications_urgences_medecin(request):
    """R√©cup√©rer les notifications d'urgences pour un m√©decin"""
    if request.user.role != 'medecin':
        return Response({'error': 'Acc√®s r√©serv√© aux m√©decins'}, status=403)

    try:
        medecin = Medecin.objects.get(user=request.user)
    except Medecin.DoesNotExist:
        return Response({'error': 'Profil m√©decin non trouv√©'}, status=404)

    # Notifications non lues en premier
    notifications = NotificationUrgence.objects.filter(
        medecin=medecin
    ).order_by('lue', '-date_envoi')[:20]

    serializer = NotificationUrgenceSerializer(notifications, many=True)
    return Response(serializer.data)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def notification_marquer_lue(request, pk):
    """Marquer une notification comme lue"""
    if request.user.role != 'medecin':
        return Response({'error': 'Acc√®s r√©serv√© aux m√©decins'}, status=403)

    try:
        medecin = Medecin.objects.get(user=request.user)
        notification = NotificationUrgence.objects.get(pk=pk, medecin=medecin)

        notification.lue = True
        notification.date_lecture = timezone.now()
        notification.save()

        return Response({'message': 'Notification marqu√©e comme lue'})
    except NotificationUrgence.DoesNotExist:
        return Response({'error': 'Notification non trouv√©e'}, status=404)


# ========== URGENCES ADMIN ==========

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def urgences_admin_dashboard(request):
    """Dashboard des urgences pour l'admin"""
    if request.user.role != 'admin':
        return Response({'error': 'Acc√®s r√©serv√© aux administrateurs'}, status=403)

    stats = {
        'total': Urgence.objects.count(),
        'en_attente': Urgence.objects.filter(statut='en_attente').count(),
        'prise_en_charge': Urgence.objects.filter(statut='prise_en_charge').count(),
        'resolues': Urgence.objects.filter(statut='resolue').count(),
        'critiques': Urgence.objects.filter(priorite='critique', statut__in=['en_attente', 'prise_en_charge']).count(),
        'par_priorite': list(Urgence.objects.values('priorite').annotate(count=models.Count('id'))),
        'temps_moyen_prise_en_charge': '√Ä calculer',  # TODO
    }

    # Urgences r√©centes
    urgences_recentes = Urgence.objects.all().order_by('-date_creation')[:10]

    return Response({
        'statistics': stats,
        'urgences_recentes': UrgenceSerializer(urgences_recentes, many=True).data
    })


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def consultation_dossier_medical(request, patient_id):
    """Consulter un dossier m√©dical (avec audit)"""
    try:
        patient = Patient.objects.get(id=patient_id)

        # LOG D'AUDIT
        log_action(
            user=request.user,
            action='read',
            model_name='DossierMedical',
            object_id=patient_id,
            details={'patient': patient.user.username},
            request=request
        )

        return Response({'message': 'Dossier m√©dical consult√©'})

    except Patient.DoesNotExist:
        return Response({'error': 'Patient non trouv√©'}, status=404)


# ========== EXPORT DONN√âES RGPD ==========

import json
from django.http import HttpResponse

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def export_mes_donnees(request):
    """Exporter toutes les donn√©es de l'utilisateur (RGPD)"""
    user = request.user

    # Collecter toutes les donn√©es
    data = {
        'utilisateur': {
            'username': user.username,
            'email': user.email,
            'prenom': user.first_name,
            'nom': user.last_name,
            'role': user.role,
            'date_inscription': user.date_joined.isoformat(),
        }
    }

    # Si patient
    if user.role == 'patient':
        try:
            patient = Patient.objects.get(user=user)
            data['patient'] = {
                'adresse': patient.adresse,
            }

            # Rendez-vous
            rendez_vous = RendezVous.objects.filter(patient=patient)
            data['rendez_vous'] = list(rendez_vous.values())

            # Consultations
            consultations = Consultation.objects.filter(patient=patient)
            data['consultations'] = list(consultations.values())

        except Patient.DoesNotExist:
            pass

    # LOG D'AUDIT
    log_action(
        user=user,
        action='export',
        model_name='UserData',
        details={'export_type': 'full'},
        request=request
    )

    # Cr√©er le fichier JSON
    response = HttpResponse(
        json.dumps(data, indent=2, ensure_ascii=False, default=str),
        content_type='application/json'
    )
    response['Content-Disposition'] = f'attachment; filename="mes_donnees_assistosante.json"'

    return response

@api_view(["GET"])
@permission_classes([IsAuthenticated])
def appointment_history(request):
    """Get appointment history for the authenticated patient"""
    patient = request.user
    rdvs = RendezVous.objects.filter(
        patient=patient
    ).exclude(
        statut="PENDING"
    ).order_by("-date", "-heure")

    serializer = RendezVousSerializer(rdvs, many=True)
    return Response(serializer.data)


@api_view(["POST"])
@permission_classes([IsAuthenticated])
def propose_reschedule(request, pk):
    """Patient proposes a new date/time for an appointment"""
    try:
        rdv = RendezVous.objects.get(pk=pk, patient=request.user)
        
        # Check if appointment can be rescheduled
        if rdv.statut in ["CANCELLED"]:
            return Response({"error": "Impossible de reprogrammer un rendez-vous annul√©"}, status=400)
        
        # Get proposed new date and time
        new_date = request.data.get("new_date")
        new_heure = request.data.get("new_heure")
        reason = request.data.get("reason", "")
        
        if not new_date or not new_heure:
            return Response({"error": "Veuillez fournir une nouvelle date et heure"}, status=400)
        
        # Create a rescheduling request (doesn't change the original appointment yet)
        # In a real implementation, you might want to create a separate model for rescheduling requests
        # For now, we'll update the appointment with a special status
        
        # Store original details if not already stored
        if not rdv.original_date:
            rdv.original_date = rdv.date
            rdv.original_heure = rdv.heure
            
        # Update with proposed new date/time
        rdv.date = new_date
        rdv.heure = new_heure
        rdv.statut = "RESCHEDULED"
        rdv.description = f"Demande de reprogrammation: {reason}" if reason else rdv.description
        rdv.save()
        
        # Send notification to the doctor about the rescheduling request
        NotificationService.send_reschedule_request(rdv)
        
        serializer = RendezVousSerializer(rdv)
        return Response(serializer.data)
        
    except RendezVous.DoesNotExist:
        return Response({"error": "Rendez-vous non trouv√©"}, status=404)
    except Exception as e:
        return Response({"error": str(e)}, status=500)

# -------------------- Ratings & Reviews --------------------
@api_view(['POST'])
@permission_classes([IsAuthenticated])
def validate_appointment(request, pk):
    """Valider un rendez-vous termin√© et cr√©er une √©valuation"""
    try:
        patient = request.user.patient_profile
        rdv = get_object_or_404(RendezVous, pk=pk, patient=request.user)
        
        # V√©rifier que le rendez-vous est termin√©
        if rdv.statut != "CONFIRMED":
            return Response({"error": "Seuls les rendez-vous confirm√©s peuvent √™tre valid√©s"}, status=400)
            
        # Marquer le rendez-vous comme termin√©
        rdv.statut = "TERMINE"
        rdv.save()
        
        # Cr√©er ou mettre √† jour l'√©valuation
        note = request.data.get('note')
        commentaire = request.data.get('commentaire', '')
        
        if note is not None:
            # V√©rifier que la note est valide (1-5)
            if not isinstance(note, int) or note < 1 or note > 5:
                return Response({"error": "La note doit √™tre un entier entre 1 et 5"}, status=400)
                
            # Cr√©er ou mettre √† jour l'√©valuation
            rating_data = {
                'medecin': rdv.medecin.id,
                'rendez_vous': rdv.id,
                'note': note,
                'commentaire': commentaire
            }
            
            # V√©rifier si une √©valuation existe d√©j√†
            try:
                rating = Rating.objects.get(patient=patient, rendez_vous=rdv)
                # Mettre √† jour l'√©valuation existante
                for key, value in rating_data.items():
                    setattr(rating, key, value)
                rating.save()
                serializer = RatingSerializer(rating)
            except Rating.DoesNotExist:
                # Cr√©er une nouvelle √©valuation
                serializer = RatingSerializer(data=rating_data, context={'request': request})
                if serializer.is_valid():
                    serializer.save()
                else:
                    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
            
            # Send notification to the doctor about the new rating
            NotificationService.send_rating_notification(rdv.medecin, note, commentaire)
            
            return Response({
                "message": "Rendez-vous valid√© et √©valuation enregistr√©e avec succ√®s",
                "rating": serializer.data
            })
        else:
            return Response({
                "message": "Rendez-vous valid√© avec succ√®s"
            })
            
    except Patient.DoesNotExist:
        return Response({"error": "Profil patient non trouv√©"}, status=status.HTTP_400_BAD_REQUEST)
    except Exception as e:
        return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_appointment_rating(request, pk):
    """R√©cup√©rer l'√©valuation d'un rendez-vous"""
    try:
        patient = request.user.patient_profile
        rdv = get_object_or_404(RendezVous, pk=pk, patient=request.user)
        
        try:
            rating = Rating.objects.get(patient=patient, rendez_vous=rdv)
            serializer = RatingSerializer(rating)
            return Response(serializer.data)
        except Rating.DoesNotExist:
            return Response({"message": "Aucune √©valuation trouv√©e pour ce rendez-vous"}, status=404)
            
    except Patient.DoesNotExist:
        return Response({"error": "Profil patient non trouv√©"}, status=status.HTTP_400_BAD_REQUEST)
    except Exception as e:
        return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


# -------------------- Search Functionality --------------------
@api_view(['GET'])
@permission_classes([AllowAny])
def search(request):
    """Global search across doctors, patients, articles, and appointments"""
    query = request.GET.get('q', '').strip()
    
    if not query:
        return Response({
            'doctors': [],
            'patients': [],
            'articles': [],
            'appointments': []
        })
    
    # Search doctors
    doctors = Medecin.objects.filter(
        Q(user__first_name__icontains=query) |
        Q(user__last_name__icontains=query) |
        Q(specialite__icontains=query)
    )[:10]
    
    doctors_data = []
    for doctor in doctors:
        doctors_data.append({
            'id': doctor.id,
            'name': f"Dr. {doctor.user.first_name} {doctor.user.last_name}",
            'specialty': doctor.specialite,
            'rating': 4.5  # In a real implementation, this would be calculated from ratings
        })
    
    # Search patients (only for authenticated users with proper permissions)
    patients_data = []
    if request.user.is_authenticated and request.user.role in ['medecin', 'admin']:
        patients = Patient.objects.filter(
            Q(user__first_name__icontains=query) |
            Q(user__last_name__icontains=query)
        )[:10]
        
        for patient in patients:
            patients_data.append({
                'id': patient.id,
                'name': f"{patient.user.first_name} {patient.user.last_name}",
                'age': 30,  # In a real implementation, this would be calculated
                'lastVisit': '2023-10-15'  # In a real implementation, this would be from actual data
            })
    
    # Search articles
    articles = Article.objects.filter(
        Q(titre__icontains=query) |
        Q(contenu__icontains=query) |
        Q(resume__icontains=query) |
        Q(tags__icontains=query)
    ).filter(statut='valide')[:10]
    
    articles_data = []
    for article in articles:
        articles_data.append({
            'id': article.id,
            'title': article.titre,
            'excerpt': article.resume,
            'author': f"Dr. {article.auteur.user.first_name} {article.auteur.user.last_name}",
            'date': article.date_publication.strftime('%Y-%m-%d') if article.date_publication else '',
            'views': article.vues
        })
    
    # Search appointments (only for authenticated users)
    appointments_data = []
    if request.user.is_authenticated:
        appointments = RendezVous.objects.filter(
            Q(patient__first_name__icontains=query) |
            Q(patient__last_name__icontains=query) |
            Q(medecin__first_name__icontains=query) |
            Q(medecin__last_name__icontains=query)
        )
        
        # Filter by user role
        if request.user.role == 'patient':
            appointments = appointments.filter(patient=request.user)
        elif request.user.role == 'medecin':
            appointments = appointments.filter(medecin=request.user)
        # Admin can see all appointments
        
        appointments = appointments[:10]
        
        for appointment in appointments:
            appointments_data.append({
                'id': appointment.id,
                'patient': f"{appointment.patient.first_name} {appointment.patient.last_name}",
                'doctor': f"Dr. {appointment.medecin.first_name} {appointment.medecin.last_name}",
                'specialty': getattr(appointment.medecin.medecin_profile, 'specialite', '') if hasattr(appointment.medecin, 'medecin_profile') else '',
                'date': appointment.date.strftime('%Y-%m-%d') if appointment.date else '',
                'time': appointment.heure.strftime('%H:%M') if appointment.heure else '',
                'status': appointment.get_statut_display()
            })
    
    return Response({
        'doctors': doctors_data,
        'patients': patients_data,
        'articles': articles_data,
        'appointments': appointments_data
    })


# -------------------- Messaging Functionality --------------------
@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_conversations(request):
    """Get all conversations for the current user"""
    conversations = request.user.conversations.all()
    serializer = ConversationSerializer(conversations, many=True, context={'request': request})
    return Response(serializer.data)


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_messages(request, conversation_id):
    """Get all messages for a specific conversation"""
    try:
        conversation = Conversation.objects.get(id=conversation_id, participants=request.user)
        messages = conversation.messages.all()
        
        # Mark messages as read (except those sent by the current user)
        for message in messages:
            if message.sender != request.user and not message.is_read:
                message.mark_as_read()
        
        serializer = MessageSerializer(messages, many=True, context={'request': request})
        return Response(serializer.data)
    except Conversation.DoesNotExist:
        return Response({"error": "Conversation non trouv√©e"}, status=404)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def create_conversation(request):
    """Create a new conversation"""
    try:
        recipient_id = request.data.get('recipient_id')
        subject = request.data.get('subject', 'Nouvelle conversation')
        
        if not recipient_id:
            return Response({"error": "ID du destinataire requis"}, status=400)
        
        try:
            recipient = User.objects.get(id=recipient_id)
        except User.DoesNotExist:
            return Response({"error": "Destinataire non trouv√©"}, status=404)
        
        # Check if conversation already exists between these two users
        existing_conversation = Conversation.objects.filter(
            participants=request.user
        ).filter(
            participants=recipient
        ).distinct()
        
        if existing_conversation.exists():
            conversation = existing_conversation.first()
        else:
            # Create new conversation
            conversation = Conversation.objects.create(subject=subject)
            conversation.participants.add(request.user, recipient)
        
        serializer = ConversationSerializer(conversation, context={'request': request})
        return Response(serializer.data, status=201)
    except Exception as e:
        return Response({"error": str(e)}, status=400)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def send_message(request):
    """Send a new message"""
    try:
        conversation_id = request.data.get('conversation_id')
        content = request.data.get('content')
        
        if not conversation_id or not content:
            return Response({"error": "ID de conversation et contenu requis"}, status=400)
        
        try:
            conversation = Conversation.objects.get(id=conversation_id, participants=request.user)
        except Conversation.DoesNotExist:
            return Response({"error": "Conversation non trouv√©e"}, status=404)
        
        # Create message
        message = Message.objects.create(
            conversation=conversation,
            sender=request.user,
            content=content
        )
        
        # Update conversation timestamp
        conversation.updated_at = timezone.now()
        conversation.save()
        
        serializer = MessageSerializer(message, context={'request': request})
        return Response(serializer.data, status=201)
    except Exception as e:
        return Response({"error": str(e)}, status=400)


@api_view(['PUT'])
@permission_classes([IsAuthenticated])
def mark_message_as_read(request, message_id):
    """Mark a message as read"""
    try:
        message = Message.objects.get(id=message_id, conversation__participants=request.user)
        message.mark_as_read()
        return Response({"message": "Message marqu√© comme lu"})
    except Message.DoesNotExist:
        return Response({"error": "Message non trouv√©"}, status=404)


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_unread_count(request):
    """Get unread messages count for the current user"""
    unread_count = Message.objects.filter(
        conversation__participants=request.user,
        is_read=False
    ).exclude(sender=request.user).count()
    
    return Response({"unread_count": unread_count})


# -------------------- Admin Appointment Management --------------------
@api_view(['GET'])
@permission_classes([IsAuthenticated])
def admin_appointments_list(request):
    """List all appointments for admin dashboard"""
    if request.user.role != 'admin':
        return Response({'error': 'Acc√®s r√©serv√© aux administrateurs'}, status=403)

    # Get all appointments with related data
    appointments = RendezVous.objects.select_related('patient', 'medecin').all().order_by('-date_creation')
    
    # Apply filters if provided
    status = request.GET.get('status')
    if status:
        appointments = appointments.filter(statut=status)
    
    date_from = request.GET.get('date_from')
    if date_from:
        appointments = appointments.filter(date__gte=date_from)
        
    date_to = request.GET.get('date_to')
    if date_to:
        appointments = appointments.filter(date__lte=date_to)
    
    serializer = RendezVousSerializer(appointments, many=True)
    return Response(serializer.data)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def admin_validate_appointment(request, pk):
    """Validate an appointment by admin"""
    if request.user.role != 'admin':
        return Response({'error': 'Acc√®s r√©serv√© aux administrateurs'}, status=403)
    
    try:
        appointment = RendezVous.objects.get(pk=pk)
        
        # Only validate confirmed appointments
        if appointment.statut != 'CONFIRMED':
            return Response({'error': 'Seuls les rendez-vous confirm√©s peuvent √™tre valid√©s'}, status=400)
        
        appointment.statut = 'TERMINE'
        appointment.save()
        
        return Response({
            'message': 'Rendez-vous valid√© avec succ√®s',
            'appointment': RendezVousSerializer(appointment).data
        })
    except RendezVous.DoesNotExist:
        return Response({'error': 'Rendez-vous non trouv√©'}, status=404)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def admin_cancel_appointment(request, pk):
    """Cancel an appointment by admin"""
    if request.user.role != 'admin':
        return Response({'error': 'Acc√®s r√©serv√© aux administrateurs'}, status=403)
    
    try:
        appointment = RendezVous.objects.get(pk=pk)
        
        # Store old status for notification
        old_status = appointment.statut
        appointment.statut = 'CANCELLED'
        appointment.save()
        
        # Send cancellation notification if not already cancelled
        if old_status != 'CANCELLED':
            NotificationService.send_appointment_cancellation(appointment)
        
        return Response({
            'message': 'Rendez-vous annul√© avec succ√®s',
            'appointment': RendezVousSerializer(appointment).data
        })
    except RendezVous.DoesNotExist:
        return Response({'error': 'Rendez-vous non trouv√©'}, status=404)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def admin_reschedule_appointment(request, pk):
    """Reschedule an appointment by admin"""
    if request.user.role != 'admin':
        return Response({'error': 'Acc√®s r√©serv√© aux administrateurs'}, status=403)
    
    try:
        appointment = RendezVous.objects.get(pk=pk)
        new_date = request.data.get('date')
        new_time = request.data.get('heure')
        
        if not new_date or not new_time:
            return Response({'error': 'Date et heure requises pour reprogrammer'}, status=400)
        
        # Store old values for notification
        old_date = appointment.date
        old_time = appointment.heure
        old_status = appointment.statut
        
        # Update appointment
        appointment.date = new_date
        appointment.heure = new_time
        appointment.statut = 'RESCHEDULED'
        appointment.save()
        
        # Send reschedule notification if not already rescheduled
        if old_status != 'RESCHEDULED':
            NotificationService.send_appointment_reschedule(appointment, old_date, old_time)
        
        return Response({
            'message': 'Rendez-vous reprogramm√© avec succ√®s',
            'appointment': RendezVousSerializer(appointment).data
        })
    except RendezVous.DoesNotExist:
        return Response({'error': 'Rendez-vous non trouv√©'}, status=404)


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def admin_appointments_statistics(request):
    """Get appointment statistics for admin dashboard"""
    if request.user.role != 'admin':
        return Response({'error': 'Acc√®s r√©serv√© aux administrateurs'}, status=403)
    
    from django.db.models import Count
    from datetime import date, timedelta
    
    today = date.today()
    week_ago = today - timedelta(days=7)
    month_ago = today - timedelta(days=30)
    
    stats = {
        'total_appointments': RendezVous.objects.count(),
        'today_appointments': RendezVous.objects.filter(date=today).count(),
        'week_appointments': RendezVous.objects.filter(date__gte=week_ago).count(),
        'month_appointments': RendezVous.objects.filter(date__gte=month_ago).count(),
        'appointments_by_status': list(RendezVous.objects.values('statut').annotate(count=Count('id'))),
        'confirmed_appointments': RendezVous.objects.filter(statut='CONFIRMED').count(),
        'cancelled_appointments': RendezVous.objects.filter(statut='CANCELLED').count(),
        'rescheduled_appointments': RendezVous.objects.filter(statut='RESCHEDULED').count(),
        'pending_appointments': RendezVous.objects.filter(statut='PENDING').count(),
        'completed_appointments': RendezVous.objects.filter(statut='TERMINE').count(),
    }
    
    return Response(stats)


# -------------------- Admin Chatbot Management --------------------
@api_view(['GET'])
@permission_classes([IsAuthenticated])
def admin_chatbot_knowledge_base(request):
    """Get all chatbot knowledge base entries for admin"""
    if request.user.role != 'admin':
        return Response({'error': 'Acc√®s r√©serv√© aux administrateurs'}, status=403)
    
    entries = ChatbotKnowledgeBase.objects.all().order_by('-created_at')
    serializer = ChatbotKnowledgeBaseSerializer(entries, many=True)
    return Response(serializer.data)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def admin_create_chatbot_entry(request):
    """Create a new chatbot knowledge base entry"""
    if request.user.role != 'admin':
        return Response({'error': 'Acc√®s r√©serv√© aux administrateurs'}, status=403)
    
    serializer = ChatbotKnowledgeBaseSerializer(data=request.data)
    if serializer.is_valid():
        serializer.save()
        return Response(serializer.data, status=status.HTTP_201_CREATED)
    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


@api_view(['PUT'])
@permission_classes([IsAuthenticated])
def admin_update_chatbot_entry(request, pk):
    """Update a chatbot knowledge base entry"""
    if request.user.role != 'admin':
        return Response({'error': 'Acc√®s r√©serv√© aux administrateurs'}, status=403)
    
    try:
        entry = ChatbotKnowledgeBase.objects.get(pk=pk)
    except ChatbotKnowledgeBase.DoesNotExist:
        return Response({'error': 'Entr√©e non trouv√©e'}, status=404)
    
    serializer = ChatbotKnowledgeBaseSerializer(entry, data=request.data, partial=True)
    if serializer.is_valid():
        serializer.save()
        return Response(serializer.data)
    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


@api_view(['DELETE'])
@permission_classes([IsAuthenticated])
def admin_delete_chatbot_entry(request, pk):
    """Delete a chatbot knowledge base entry"""
    if request.user.role != 'admin':
        return Response({'error': 'Acc√®s r√©serv√© aux administrateurs'}, status=403)
    
    try:
        entry = ChatbotKnowledgeBase.objects.get(pk=pk)
        entry.delete()
        return Response({'message': 'Entr√©e supprim√©e avec succ√®s'}, status=status.HTTP_204_NO_CONTENT)
    except ChatbotKnowledgeBase.DoesNotExist:
        return Response({'error': 'Entr√©e non trouv√©e'}, status=404)


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def admin_chatbot_statistics(request):
    """Get chatbot statistics for admin dashboard"""
    if request.user.role != 'admin':
        return Response({'error': 'Acc√®s r√©serv√© aux administrateurs'}, status=403)
    
    from django.db.models import Count
    
    # Get top questions from conversation history
    top_questions = ChatbotConversation.objects.values('message_user').annotate(
        count=Count('message_user')
    ).order_by('-count')[:10]
    
    stats = {
        'total_conversations': ChatbotConversation.objects.count(),
        'total_users': ChatbotConversation.objects.values('patient').distinct().count(),
        'avg_response_time': '2.3s',  # This would need to be calculated in a real implementation
        'top_questions': [
            {'question': item['message_user'], 'count': item['count']} 
            for item in top_questions
        ]
    }
    
    return Response(stats)
